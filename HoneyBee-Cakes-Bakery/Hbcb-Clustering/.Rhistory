# each variable?
miss_var_summary(Hbcb_training_data)
# STEP 4 Training and Saving Clustering Algorithm
set.seed(7)
# Select columns 3 and 4 for k-means clustering
columns_for_clustering <- Hbcb_training_data[, c(3, 4)]
# Perform k-means clustering
kmeans_model <- kmeans(columns_for_clustering, centers = 4, nstart = 20)
# Add the cluster assignments to the dataset
Hbcb_training_data$cluster <- kmeans_model$cluster
# Visualize the clustering results (modify this based on your requirements)
# For example, if you want to visualize column 3 against column 4:
plot(productId ~ quantity,
data = Hbcb_training_data,
col = Hbcb_training_data$cluster,
main = "Customer Segmentation")
# Saving the k-means model
saveRDS(Hbcb_training_data, "./Hbcb_customer_segmentation model.rds")
# The saved model can then be loaded later
loaded_Hbcb_training_data <- readRDS("./Hbcb_customer_segmentation model.rds")
print(loaded_Hbcb_training_data)
view(loaded_Hbcb_training_data)
View(Hbcb_training_data)
.libPaths()
lapply(.libPaths(), list.files)
if (require("languageserver")) {
require("languageserver")
} else {
install.packages("languageserver", dependencies = TRUE,
repos = "https://cloud.r-project.org")
}
# STEP 1. Install and Load the Required Packages ----
## readr ----
if (require("readr")) {
require("readr")
} else {
install.packages("readr", dependencies = TRUE,
repos = "https://cloud.r-project.org")
}
## naniar ----
if (require("naniar")) {
require("naniar")
} else {
install.packages("naniar", dependencies = TRUE,
repos = "https://cloud.r-project.org")
}
## ggplot2 ----
if (require("ggplot2")) {
require("ggplot2")
} else {
install.packages("ggplot2", dependencies = TRUE,
repos = "https://cloud.r-project.org")
}
## corrplot ----
if (require("corrplot")) {
require("corrplot")
} else {
install.packages("corrplot", dependencies = TRUE,
repos = "https://cloud.r-project.org")
}
## ggcorrplot ----
if (require("ggcorrplot")) {
require("ggcorrplot")
} else {
install.packages("ggcorrplot", dependencies = TRUE,
repos = "https://cloud.r-project.org")
}
## caret ----
if (require("caret")) {
require("caret")
} else {
install.packages("caret", dependencies = TRUE,
repos = "https://cloud.r-project.org")
}
## tidyverse ----
if (require("tidyverse")) {
require("tidyverse")
} else {
install.packages("tidyverse", dependencies = TRUE,
repos = "https://cloud.r-project.org")
}
## plumber ----
if (require("plumber")) {
require("plumber")
} else {
install.packages("plumber", dependencies = TRUE,
repos = "https://cloud.r-project.org")
}
library(readr)
Hbcb_training_data <- read_csv("Hbcb-training-data.csv")
View(Hbcb_training_data)
str(Hbcb_training_data)
dim(Hbcb_training_data)
head(Hbcb_training_data)
summary(Hbcb_training_data)
# STEP 3. Check for Missing Data and Address it ----
# Are there missing values in the dataset?
any_na(Hbcb_training_data)
# How many?
n_miss(Hbcb_training_data)
# What is the proportion of missing data in the entire dataset?
prop_miss(Hbcb_training_data)
# What is the number and percentage of missing values grouped by
# each variable?
miss_var_summary(Hbcb_training_data)
# STEP 4 Training and Saving Clustering Algorithm
set.seed(7)
# Select columns 3 and 4 for k-means clustering
columns_for_clustering <- Hbcb_training_data[, c(3, 4)]
# Perform k-means clustering
kmeans_model <- kmeans(columns_for_clustering, centers = 4, nstart = 20)
# Add the cluster assignments to the dataset
Hbcb_training_data$cluster <- kmeans_model$cluster
# Visualize the clustering results (modify this based on your requirements)
# For example, if you want to visualize column 3 against column 4:
plot(productId ~ quantity,
data = Hbcb_training_data,
col = Hbcb_training_data$cluster,
main = "Customer Segmentation")
# STEP 4 Training and Saving Clustering Algorithm
set.seed(7)
# Select columns 3 and 4 for k-means clustering
columns_for_clustering <- Hbcb_training_data[, c(3, 4)]
# Perform k-means clustering
kmeans_model <- kmeans(columns_for_clustering, centers = 4, nstart = 20)
# Add the cluster assignments to the dataset
Hbcb_training_data$cluster <- kmeans_model$cluster
# Visualize the clustering results (modify this based on your requirements)
# For example, if you want to visualize column 3 against column 4:
plot(productId ~ quantity,
data = Hbcb_training_data,
col = Hbcb_training_data$cluster,
main = "Customer Segmentation")
# Saving the k-means model
saveRDS(Hbcb_training_data, "./Hbcb_customer_segmentation model.rds")
# The saved model can then be loaded later
loaded_Hbcb_training_data <- readRDS("./Hbcb_customer_segmentation model.rds")
print(loaded_Hbcb_training_data)
view(loaded_Hbcb_training_data)
predict_cluster <- function(arg_productId, arg_quantity) {
to_be_predicted <- data.frame(productId = as.numeric(arg_productId),
quantity = as.numeric(arg_quantity))
predict(loaded_Hbcb_training_data, to_be_predicted)
}
api <- plumber::plumb("Hbcb-Clustering-Model.R")
api$run(host = "127.0.0.1", port = 5022)
.libPaths()
lapply(.libPaths(), list.files)
if (require("languageserver")) {
require("languageserver")
} else {
install.packages("languageserver", dependencies = TRUE,
repos = "https://cloud.r-project.org")
}
# STEP 1. Install and load the required packages ----
## plumber ----
if (require("plumber")) {
require("plumber")
} else {
install.packages("plumber", dependencies = TRUE,
repos = "https://cloud.r-project.org")
}
# STEP 2. Process a Plumber API
# This allows us to process a plumber API
api <- plumber::plumb("Hbcb-Clustering-Model.R")
api$run(host = "127.0.0.1", port = 5022)
api$run(host = "127.0.0.1", port = 5022)
# Saving the k-means model
saveRDS(model_to_predict_clusters, "./Hbcb_customer_segmentation_model.rds")
model_to_predict_clusters <-
train(cluster ~ ., data = Hbcb_training_data, method = "svmRadial",
metric = "Accuracy", trControl = train_control)
library(readr)
Hbcb_training_data <- read_csv("Hbcb-training-data.csv")
str(Hbcb_training_data)
dim(Hbcb_training_data)
head(Hbcb_training_data)
summary(Hbcb_training_data)
# STEP 3. Check for Missing Data and Address it ----
# Are there missing values in the dataset?
any_na(Hbcb_training_data)
# How many?
n_miss(Hbcb_training_data)
# What is the proportion of missing data in the entire dataset?
prop_miss(Hbcb_training_data)
# What is the number and percentage of missing values grouped by
# each variable?
miss_var_summary(Hbcb_training_data)
# STEP 4 Training and Saving Clustering Algorithm
set.seed(7)
# Select columns 3 and 4 for k-means clustering
columns_for_clustering <- Hbcb_training_data[, c(3, 4)]
# Perform k-means clustering
kmeans_model <- kmeans(columns_for_clustering, centers = 4, nstart = 20)
# Add the cluster assignments to the dataset
Hbcb_training_data$cluster <- kmeans_model$cluster
# Visualize the clustering results (modify this based on your requirements)
# For example, if you want to visualize column 3 against column 4:
plot(productId ~ quantity,
data = Hbcb_training_data,
col = Hbcb_training_data$cluster,
main = "Customer Segmentation")
model_to_predict_clusters <-
train(cluster ~ ., data = Hbcb_training_data, method = "svmRadial",
metric = "Accuracy", trControl = train_control)
# Saving the k-means model
saveRDS(model_to_predict_clusters, "./Hbcb_customer_segmentation_model.rds")
# Visualize the clustering results (modify this based on your requirements)
# For example, if you want to visualize column 3 against column 4:
plot(productId ~ quantity,
data = Hbcb_training_data,
col = Hbcb_training_data$cluster,
main = "Customer Segmentation")
# Saving the k-means model
saveRDS(model_to_predict_clusters, "./Hbcb_customer_segmentation_model.rds")
model_to_predict_clusters <-
train(cluster ~ ., data = Hbcb_training_data, method = "svmRadial",
metric = "Accuracy", trControl = train_control)
train_control <- trainControl(method = "cv", number = 5)
model_to_predict_clusters <-
train(cluster ~ ., data = Hbcb_training_data, method = "svmRadial",
metric = "Accuracy", trControl = train_control)
# Saving the k-means model
saveRDS(model_to_predict_clusters, "./Hbcb_customer_segmentation_model.rds")
train_control <- trainControl(method = "cv", number = 5)
model_to_predict_clusters <-
train(cluster ~ ., data = Hbcb_training_data, method = "svmRadial",
metric = "Accuracy", trControl = train_control)
## dplyr ----
if (require("dplyr")) {
require("dplyr")
} else {
install.packages("dplyr", dependencies = TRUE,
repos = "https://cloud.r-project.org")
}
train_control <- trainControl(method = "cv", number = 5)
Hbcb_training_data %>% mutate(cluster = as.factor(cluster))
model_to_predict_clusters <-
train(cluster ~ ., data = Hbcb_training_data, method = "svmRadial",
metric = "Accuracy", trControl = train_control)
train_control <- trainControl(method = "cv", number = 5)
Hbcb_training_data %>% mutate(cluster = as.factor(cluster))
model_to_predict_clusters <-
train(cluster ~ ., data = Hbcb_training_data, method = "svmRadial",
metric = "Accuracy", trControl = train_control)
Hbcb_training_data %>% mutate(cluster = as.factor(cluster))
train_control <- trainControl(method = "cv", number = 5)
Hbcb_training_data  <- Hbcb_training_data %>% mutate(cluster = as.factor(cluster))
model_to_predict_clusters <-
train(cluster ~ ., data = Hbcb_training_data, method = "svmRadial",
metric = "Accuracy", trControl = train_control)
model_to_predict_clusters <-
train(cluster ~ ., data = Hbcb_training_data, method = "svmRadial",
metric = "Accuracy", trControl = train_control)
# Saving the k-means model
saveRDS(model_to_predict_clusters, "./Hbcb_customer_segmentation_model.rds")
# The saved model can then be loaded later
loaded_Hbcb_training_data <- readRDS("./Hbcb_customer_segmentation model.rds")
# Saving the k-means model
saveRDS(model_to_predict_clusters, "./Hbcb_customer_segmentation_model.rds")
# The saved model can then be loaded later
loaded_Hbcb_training_data <- readRDS("./Hbcb_customer_segmentation model.rds")
print(loaded_Hbcb_training_data)
view(loaded_Hbcb_training_data)
predict_cluster <- function(arg_productId, arg_quantity) {
to_be_predicted <- data.frame(productId = as.numeric(arg_productId),
quantity = as.numeric(arg_quantity))
predict(loaded_Hbcb_training_data, to_be_predicted)
}
lapply(.libPaths(), list.files)
if (require("languageserver")) {
require("languageserver")
} else {
install.packages("languageserver", dependencies = TRUE,
repos = "https://cloud.r-project.org")
}
# STEP 1. Install and load the required packages ----
## plumber ----
if (require("plumber")) {
require("plumber")
} else {
install.packages("plumber", dependencies = TRUE,
repos = "https://cloud.r-project.org")
}
# STEP 2. Process a Plumber API
# This allows us to process a plumber API
api <- plumber::plumb("Hbcb-Clustering-Model.R")
api$run(host = "127.0.0.1", port = 5022)
# Saving the k-means model
saveRDS(model_to_predict_clusters, "./Hbcb_customer_segmentation_model.rds")
# The saved model can then be loaded later
model_to_predict_clustersa <- readRDS("./Hbcb_customer_segmentation model.rds")
# The saved model can then be loaded later
model_to_predict_clustersa <- readRDS("./Hbcb_customer_segmentation model.rds")
print(model_to_predict_clusters)
view(model_to_predict_clusters)
predict_cluster <- function(arg_productId, arg_quantity) {
to_be_predicted <- data.frame(productId = as.numeric(arg_productId),
quantity = as.numeric(arg_quantity))
predict(model_to_predict_clusters, to_be_predicted)
}
.libPaths()
lapply(.libPaths(), list.files)
if (require("languageserver")) {
require("languageserver")
} else {
install.packages("languageserver", dependencies = TRUE,
repos = "https://cloud.r-project.org")
}
# STEP 1. Install and load the required packages ----
## plumber ----
if (require("plumber")) {
require("plumber")
} else {
install.packages("plumber", dependencies = TRUE,
repos = "https://cloud.r-project.org")
}
# STEP 2. Process a Plumber API
# This allows us to process a plumber API
api <- plumber::plumb("Hbcb-Clustering-Model.R")
api$run(host = "127.0.0.1", port = 5022)
# Perform k-means clustering
kmeans_model <- kmeans(columns_for_clustering, centers = 4, nstart = 20)
# Add the cluster assignments to the dataset
Hbcb_training_data$cluster <- kmeans_model$cluster
# Visualize the clustering results (modify this based on your requirements)
# For example, if you want to visualize column 3 against column 4:
plot(productId ~ quantity,
data = Hbcb_training_data,
col = Hbcb_training_data$cluster,
main = "Customer Segmentation")
train_control <- trainControl(method = "cv", number = 5)
Hbcb_training_data  <- Hbcb_training_data %>% mutate(cluster = as.factor(cluster))
model_to_predict_clusters <-
train(cluster ~ ., data = Hbcb_training_data, method = "svmRadial",
metric = "Accuracy", trControl = train_control)
# Saving the k-means model
saveRDS(model_to_predict_clusters, "./Hbcb_customer_segmentation_model.rds")
# The saved model can then be loaded later
model_to_predict_clusters <- readRDS("./Hbcb_customer_segmentation model.rds")
print(model_to_predict_clusters)
predict_cluster <- function(arg_productId, arg_quantity) {
# Create a data frame using the arguments
to_be_predicted <- data.frame(productId = as.numeric(arg_productId),
quantity = as.numeric(arg_quantity))
# Perform k-means clustering on the input data to obtain clusters
to_be_predicted$cluster <- predict(kmeans_model, to_be_predicted)
# Predict the cluster using the model_to_predict_clusters
predict(model_to_predict_clusters, to_be_predicted)
}
.libPaths()
lapply(.libPaths(), list.files)
if (require("languageserver")) {
require("languageserver")
} else {
install.packages("languageserver", dependencies = TRUE,
repos = "https://cloud.r-project.org")
}
# STEP 1. Install and load the required packages ----
## plumber ----
if (require("plumber")) {
require("plumber")
} else {
install.packages("plumber", dependencies = TRUE,
repos = "https://cloud.r-project.org")
}
# STEP 2. Process a Plumber API
# This allows us to process a plumber API
api <- plumber::plumb("Hbcb-Clustering-Model.R")
api$run(host = "127.0.0.1", port = 5022)
.libPaths()
lapply(.libPaths(), list.files)
if (require("languageserver")) {
require("languageserver")
} else {
install.packages("languageserver", dependencies = TRUE,
repos = "https://cloud.r-project.org")
}
# STEP 1. Install and Load the Required Packages ----
## readr ----
if (require("readr")) {
require("readr")
} else {
install.packages("readr", dependencies = TRUE,
repos = "https://cloud.r-project.org")
}
## naniar ----
if (require("naniar")) {
require("naniar")
} else {
install.packages("naniar", dependencies = TRUE,
repos = "https://cloud.r-project.org")
}
## ggplot2 ----
if (require("ggplot2")) {
require("ggplot2")
} else {
install.packages("ggplot2", dependencies = TRUE,
repos = "https://cloud.r-project.org")
}
## corrplot ----
if (require("corrplot")) {
require("corrplot")
} else {
install.packages("corrplot", dependencies = TRUE,
repos = "https://cloud.r-project.org")
}
## ggcorrplot ----
if (require("ggcorrplot")) {
require("ggcorrplot")
} else {
install.packages("ggcorrplot", dependencies = TRUE,
repos = "https://cloud.r-project.org")
}
## caret ----
if (require("caret")) {
require("caret")
} else {
install.packages("caret", dependencies = TRUE,
repos = "https://cloud.r-project.org")
}
## dplyr ----
if (require("dplyr")) {
require("dplyr")
} else {
install.packages("dplyr", dependencies = TRUE,
repos = "https://cloud.r-project.org")
}
## tidyverse ----
if (require("tidyverse")) {
require("tidyverse")
} else {
install.packages("tidyverse", dependencies = TRUE,
repos = "https://cloud.r-project.org")
}
## plumber ----
if (require("plumber")) {
require("plumber")
} else {
install.packages("plumber", dependencies = TRUE,
repos = "https://cloud.r-project.org")
}
library(readr)
Hbcb_training_data <- read_csv("Hbcb-training-data.csv")
View(Hbcb_training_data)
str(Hbcb_training_data)
dim(Hbcb_training_data)
head(Hbcb_training_data)
summary(Hbcb_training_data)
# STEP 3. Check for Missing Data and Address it ----
# Are there missing values in the dataset?
any_na(Hbcb_training_data)
# How many?
n_miss(Hbcb_training_data)
# What is the proportion of missing data in the entire dataset?
prop_miss(Hbcb_training_data)
# What is the number and percentage of missing values grouped by
# each variable?
miss_var_summary(Hbcb_training_data)
# STEP 4 Training and Saving Clustering Algorithm
set.seed(7)
# Select columns 3 and 4 for k-means clustering
columns_for_clustering <- Hbcb_training_data[, c(3, 4)]
# Perform k-means clustering
kmeans_model <- kmeans(Hbcb_training_data[, c(3, 4)], centers = 4, nstart = 20)
Hbcb_training_data$cluster <- kmeans_model$cluster
# Add the cluster assignments to the dataset
Hbcb_training_data$cluster <- kmeans_model$cluster
# Visualize the clustering results (modify this based on your requirements)
# For example, if you want to visualize column 3 against column 4:
plot(productId ~ quantity,
data = Hbcb_training_data,
col = Hbcb_training_data$cluster,
main = "Customer Segmentation")
train_control <- trainControl(method = "cv", number = 5)
Hbcb_training_data  <- Hbcb_training_data %>% mutate(cluster = as.factor(cluster))
model_to_predict_clusters <-
train(cluster ~ ., data = Hbcb_training_data, method = "svmRadial",
metric = "Accuracy", trControl = train_control)
# Saving the k-means model
saveRDS(kmeans_model, "./Hbcb_kmeans_model.rds")
# The saved kmeans model can then be loaded later
kmeans_model <- readRDS("./Hbcb_kmeans_model.rds")
predict_cluster <- function(arg_productId, arg_quantity) {
# Create a data frame using the arguments
to_be_predicted <- data.frame(productId = as.numeric(arg_productId),
quantity = as.numeric(arg_quantity))
# Perform k-means clustering on the input data to obtain clusters
to_be_predicted$cluster <- predict(kmeans_model, to_be_predicted)
# Predict the segment using the model_to_predict_clusters
predict(model_to_predict_clusters, to_be_predicted)
}
.libPaths()
lapply(.libPaths(), list.files)
if (require("languageserver")) {
require("languageserver")
} else {
install.packages("languageserver", dependencies = TRUE,
repos = "https://cloud.r-project.org")
}
# STEP 1. Install and load the required packages ----
## plumber ----
if (require("plumber")) {
require("plumber")
} else {
install.packages("plumber", dependencies = TRUE,
repos = "https://cloud.r-project.org")
}
# STEP 2. Process a Plumber API
# This allows us to process a plumber API
api <- plumber::plumb("Hbcb-Clustering-Model.R")
api$run(host = "127.0.0.1", port = 5022)
